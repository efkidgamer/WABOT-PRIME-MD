console.log('Starting...');

let { spawn } = require('child_process');
let path = require('path');
let fs = require('fs');
let package = require('./package.json');
const CFonts = require('cfonts');
const { Baileys } = require('@adiwajshing/baileys');

CFonts.say('Prime-MD\nWhatsApp Bot', {
  font: 'chrome',
  align: 'center',
  gradient: ['red', 'magenta']
});

CFonts.say(`'${package.name}' By ${package.author.name}`, {
  font: 'console',
  align: 'center',
  gradient: ['red', 'magenta']
});

var isRunning = false;

const config = require('./config');
const bot = Baileys(config.sessionID, config.phoneNumber, config.verificationCode);

const commands = {};
fs.readdirSync('./commands').forEach((file) => {
  const commandName = file.split('.')[0];
  commands[commandName] = require(`./commands/${file}`);
});

/**
 * Start a js file
 * @param {String} file `path/to/file`
 */
function start(file) {
  if (isRunning) return;
  isRunning = true;
  let args = [path.join(__dirname, file), ...process.argv.slice(2)];

  CFonts.say([process.argv[0], ...args].join(' '), {
    font: 'console',
    align: 'center',
    gradient: ['red', 'magenta']
  });

  let p = spawn(process.argv[0], args, {
    stdio: ['inherit', 'inherit', 'inherit', 'ipc']
  });

  p.on('message', (data) => {
    console.log('[RECEIVED]', data);
    switch (data) {
      case 'reset':
        p.kill();
        isRunning = false;
        start.apply(this, arguments);
        break;
      case 'uptime':
        p.send(process.uptime());
        break;
    }
  });

  p.on('exit', (code) => {
    isRunning = false;
    console.error('Exited with code:', code);
    if (code === 0) return;
    fs.watchFile(args[0], () => {
      fs.unwatchFile(args[0]);
      start(file);
    });
  });

  bot.on('message', async (message) => {
    const { from, text } = message;
    console.log(`Received message from ${from}: ${text}`);

    if (!text.startsWith(config.prefix)) return;

    const command = text.slice(config.prefix.length).trim().split(' ')[0];
    const args = text.slice(config.prefix.length).trim().split(' ').slice(1);

    const isAdmin = config.admin.numbers.includes(from);
    const isOwner = config.owner === from;

    const commandFile = commands[command.toLowerCase()];

    if (commandFile) {
      if (commandFile.requiresAdmin && !(isAdmin || isOwner)) {
        bot.sendMessage(from, `You don't have permission to use this command. Contact ${package.name} admins for assistance.`);
        return;
      }

      await commandFile.execute(bot, from, args);
    } else if (isAdmin || isOwner) {
      switch (command.toLowerCase()) {
        case 'ban':
          bot.sendMessage(from, 'User banned successfully.');
          break;
        case 'unban':
          bot.sendMessage(from, 'User unbanned successfully.');
          break;
        case 'mute':
          bot.sendMessage(from, 'User muted successfully.');
          break;
        case 'unmute':
          bot.sendMessage(from, 'User unmuted successfully.');
          break;
        case 'kick':
          bot.sendMessage(from, 'User kicked successfully.');
          break;
        case 'promote':
          bot.sendMessage(from, 'User promoted successfully.');
          break;
        case 'restart':
          bot.sendMessage(from, 'Restarting Bot...');
          process.exit(0);
          break;
        default:
          bot.sendMessage(from, `Invalid command. Type ${config.prefix}help for ${package.name} commands.`);
      }
    } else {
      bot.sendMessage(from, `Unknown command. Type ${config.prefix}help for ${package.name} commands.`);
    }
  });

  bot.on('connect', () => {
    console.log(`${package.name} connected!`);
  });

  bot.on('disconnect', () => {
    console.log(`${package.name} disconnected!`);
  });

  bot.connect();
}

start('main.js');